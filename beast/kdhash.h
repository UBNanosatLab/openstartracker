#ifndef KDHASH_H
#define KDHASH_H
#include <stdint.h>

/**
 * multidimensional hash function based on morton codes
 * 
 * the magic numbers were generated by doc/gen_interleave.py
 *
 * If we ever need to implement decoding, useful info can be found here:
 * https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/
 * (basically just do everything backwards)
 * 
 */
struct kdhash_2f {
	#define DIAM 0xffffffff
	#define R_IN (DIAM/2)
	#define R_OUT (R_IN+1)
	#define INTERLEAVE(X)\
		if (X > DIAM) X=DIAM;\
		if (X < 0) X=0;\
		X = (X | X << 16) & 0xffff0000ffff;\
		X = (X | X << 8) & 0xff00ff00ff00ff;\
		X = (X | X << 4) & 0xf0f0f0f0f0f0f0f;\
		X = (X | X << 2) & 0x3333333333333333;\
		X = (X | X << 1) & 0x5555555555555555;
	
	/**
	* @brief hash function which interleaves values so that nearby coordinates will have nearby hashes
	* this approach also  also allows you to truncate the hash when less precision is needed
	*/
	static inline uint64_t hash(const float x0,const float x1){
		int64_t h0=R_OUT*(x0+1.0);
		int64_t h1=R_OUT*(x1+1.0);
		INTERLEAVE(h0)
		INTERLEAVE(h1)
		return h1<<1|h0;
	}
	
	/**
	* @brief returns returns the number of bits we need to truncate in order to search a specified range
	*/
	static inline uint8_t bin_size(const float r) {
		int64_t h = R_OUT*r;
		if (h > R_IN) h=R_IN;
		if (h < 0) h=0;
		uint8_t sz=0;
		for (;h;h>>=1) sz+=1;
		return sz;
	}
	/**
	* @brief returns a mask which can be used to clamp the hash to a specified precision
	* @param r mask a range of this size, rounded up to the nearest power of two
	*/
	static inline uint64_t mask(const float r) {
		uint64_t mask=-1;
		return mask<<2*bin_size(r);
	}
	
	/**
	* @brief As before, but allows independent ranges for the different parameters 
	*/
	static inline uint64_t mask(const float r0,const float r1){
		int64_t h0=R_OUT>>bin_size(r0);
		int64_t h1=R_OUT>>bin_size(r1);
		INTERLEAVE(h0)
		INTERLEAVE(h1)
		return h1<<1|h0;
	}
	#undef INTERLEAVE
	#undef R_OUT
	#undef R_IN
	#undef DIAM
};

struct kdhash_3f {
	#define DIAM 0x1fffff
	#define R_IN (DIAM/2)
	#define R_OUT (R_IN+1)
	#define INTERLEAVE(X)\
		if (X > DIAM) X=DIAM;\
		if (X < 0) X=0;\
		X = (X | X <<32) & 0x001f00000000ffff;\
		X = (X | X <<16) & 0x001f0000ff0000ff;\
		X = (X | X << 8) & 0x100f00f00f00f00f;\
		X = (X | X << 4) & 0x10c30c30c30c30c3;\
		X = (X | X << 2) & 0x1249249249249249;
	///See kdhash_2f::hash
	static inline uint64_t hash(const float x0,const float x1,const float x2){
		int64_t h0=R_OUT*(x0+1.0);
		int64_t h1=R_OUT*(x1+1.0);
		int64_t h2=R_OUT*(x2+1.0);
		INTERLEAVE(h0)
		INTERLEAVE(h1)
		INTERLEAVE(h2)
		return h2<<2|h1<<1|h0;
	}
	///See kdhash_2f::bin_size
	static inline uint8_t bin_size(const float radians) {
		int64_t h = R_OUT*radians;
		if (h > R_IN) h=R_IN;
		if (h < 0) h=0;
		uint8_t sz=0;
		for (;h;h>>=1) sz+=1;
		return sz;
	}
	///See kdhash_2f::mask
	static inline uint64_t mask(const float radians) {
		uint64_t mask=-1;
		return mask<<3*bin_size(radians);
	}
	
	///See kdhash_2f::mask
	static inline uint64_t mask(const float r0,const float r1,const float r2){
		int64_t h0=R_OUT>>bin_size(r0);
		int64_t h1=R_OUT>>bin_size(r1);
		int64_t h2=R_OUT>>bin_size(r2);
		INTERLEAVE(h0)
		INTERLEAVE(h1)
		INTERLEAVE(h2)
		return h2<<2|h1<<1|h0;
	}
	#undef INTERLEAVE
	#undef R_OUT
	#undef R_IN
	#undef DIAM
};

struct kdhash_4f {
	#define DIAM 0xfffff
	#define R_IN (DIAM/2)
	#define R_OUT (R_IN+1)
	#define INTERLEAVE(X)\
		if (X > DIAM) X=DIAM;\
		if (X < 0) X=0;\
		X = (X | X << 32) & 0xf800000007ff;\
		X = (X | X << 16) & 0xf80007c0003f;\
		X = (X | X << 8) & 0xc0380700c03807;\
		X = (X | X << 4) & 0x843084308430843;\
		X = (X | X << 2) & 0x909090909090909;\
		X = (X | X << 1) & 0x1111111111111111;

	///See kdhash_2f::hash
	static inline uint64_t hash(const float x0,const float x1,const float x2,const float x3){
		int64_t h0=R_OUT*(x0+1.0);
		int64_t h1=R_OUT*(x1+1.0);
		int64_t h2=R_OUT*(x2+1.0);
		int64_t h3=R_OUT*(x3+1.0);
		INTERLEAVE(h0)
		INTERLEAVE(h1)
		INTERLEAVE(h2)
		INTERLEAVE(h3)
		return h3<<3|h2<<2|h1<<1|h0;
	}
	///See kdhash_2f::bin_size
	static inline uint8_t bin_size(const float radians) {
		int64_t h = R_OUT*radians;
		if (h > R_IN) h=R_IN;
		if (h < 0) h=0;
		uint8_t sz=0;
		for (;h;h>>=1) sz+=1;
		return sz;
	}
	///See kdhash_2f::mask
	static inline uint64_t mask(const float radians) {
		uint64_t mask=-1;
		return mask<<4*bin_size(radians);
	}
	///See kdhash_2f::mask
	static inline uint64_t mask(const float r0,const float r1,const float r2,const float r3){
		int64_t h0=R_OUT>>bin_size(r0);
		int64_t h1=R_OUT>>bin_size(r1);
		int64_t h2=R_OUT>>bin_size(r2);
		int64_t h3=R_OUT>>bin_size(r3);
		INTERLEAVE(h0)
		INTERLEAVE(h1)
		INTERLEAVE(h2)
		INTERLEAVE(h3)
		return h0<<3|h1<<2|h2<<1|h3;
	}
	#undef INTERLEAVE
	#undef R_OUT
	#undef R_IN
	#undef DIAM
};
#endif
